{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Arial Black;}{\f1\fnil\fcharset0 Calibri;}{\f2\fnil Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\b\f0\fs22\lang9 1. What React hooks do you know?\par
\f1\fs24 useState\b0\fs22 : Used for managing state in functional components.\par
\b useEffec\b0 t: Used for performing side effects in functional components, such as fetching data or subscribing to events.\par
\b useContex\b0 t: Used for accessing the value of a React context within a functional component.\par
\b useRef\b0 : Used for creating mutable references to elements or values that persist across renders.\par
\b useCallback\b0 : Used for memoizing functions to prevent unnecessary re-renders.\par
\b useMemo\b0 : Used for memoizing values to improve performance by caching expensive computations.\par
\b useReducer\b0 : Used for managing state with a reducer function, similar to how Redux works.\par
\b useLayoutEffect\b0 : Similar to useEffect, but the effect runs synchronously after all DOM mutations.\par
These hooks provide powerful tools for managing state, handling side effects, and reusing logic in React functional components.\par
Learn more\par
\par
\b\f0 2. What is Virtual DOM?\b0\f1\par
Virtual DOM is a concept in React where a lightweight, virtual representation of the actual DOM (Document Object Model) is created and stored in memory. It is a programming technique used to optimize the performance of web applications.\par
When changes are made to the data or state of a React component, the virtual DOM is updated instead of directly manipulating the real DOM. The virtual DOM then calculates the difference between the previous and updated state of the component, known as the "diffing" process.\par
Once the differences are identified, React efficiently updates only the necessary parts of the real DOM to reflect the changes. This approach minimizes the number of actual DOM manipulations and improves the overall performance of the application.\par
By using the virtual DOM, React provides a way to create dynamic and interactive user interfaces while ensuring optimal efficiency and rendering speed.\par
\par
\b\f0 3. How to render an array of elements?\b0\f1\par
To render an array of elements, you can use the map() method to iterate over the array and return a new array of React elements.\par
const languages = [\par
  "JavaScript",\par
  "TypeScript",\par
  "Python",\par
];\par
\par
function App() \{\par
  return (\par
    <div>\par
      <ul>\{languages.map((language) => <li>\{language\}</li>)\}</ul>\par
    </div>\par
  );\par
\}\par
Learn more\par
\par
\b\f0 4. What is the difference between controlled and uncontrolled components?\par
\b0\f1 The difference between controlled and uncontrolled components lies in how they manage and update their state.\par
\par
Controlled components are components where the state is controlled by React. The component receives its current value and updates it through props. It also triggers a callback function when the value changes. This means that the component doesn't store its own internal state. Instead, the parent component manages and passes the value down to the controlled component.\par
import \{ useState \} from 'react'; \par
\par
function App() \{ \par
  const [value, setValue] = useState(''); \par
\par
  return ( \par
    <div> \par
      <h3>Controlled Component</h3> \par
      <input name="name" value=\{name\} onChange=\{(e) => setValue(e.target.value)\} />\par
      <button onClick=\{() => console.log(value)\}>Get Value</button> \par
    </div> \par
  ); \par
\} \par
Uncontrolled components, on the other hand, manage their own state internally using refs or other methods. They store and update their state independently, without relying on props or callbacks. The parent component has less control over the state of uncontrolled components.\par
import \{ useRef \} from 'react'; \par
\par
function App() \{ \par
  const inputRef = useRef(null); \par
\par
  return ( \par
    <div className="App"> \par
      <h3>Uncontrolled Component</h3> \par
      <input type="text" name="name" ref=\{inputRef\} /> \par
      <button onClick=\{() => console.log(inputRef.current.value)\}>Get Value</button> \par
    </div> \par
  ); \par
\} \par
\par
Learn more\par
\par
\b\f0 5. What is the difference between class-based and functional React components?\par
\b0\f1 The main difference between class-based and functional components is how they are defined and the syntax they use.\par
\par
Class-based components are defined as ES6 classes and extend the React.Component class. They use the render method to return the JSX (JavaScript XML) that defines the component's output. Class components have access to component lifecycle methods and state management through this.state and this.setState().\par
class App extends React.Component \{\par
  state = \{\par
    value: 0,\par
  \};\par
\par
  handleAgeChange = () => \{\par
    this.setState(\{\par
      value: this.state.value + 1 \par
    \});\par
  \};\par
\par
  render() \{\par
    return (\par
      <>\par
        <p>Value is \{this.state.value\}</p>\par
        <button onClick=\{this.handleAgeChange\}>\par
        Increment value\par
        </button>\par
      </>\par
    );\par
  \}\par
\}\par
Functional components, on the other hand, are defined as simple JavaScript functions. They take in props as arguments and return JSX directly. Functional components do not have access to lifecycle methods or state. However, with the introduction of React Hooks in React 16.8, functional components can now manage state and use other features such as context and effects.\par
import \{ useState \} from 'react';\par
\par
const App = () => \{\par
  const [value, setValue] = useState(0);\par
\par
  const handleAgeChange = () => \{\par
    setValue(value + 1);\par
  \};\par
\par
  return (\par
      <>\par
        <p>Value is \{value\}</p>\par
        <button onClick=\{handleAgeChange\}>\par
        Increment value\par
        </button>\par
      </>\par
  );\par
\}\par
In general, functional components are considered simpler and easier to read and test. It is recommended to use functional components whenever possible, unless there is a specific need for class-based components.\par
\par
\b\f0 6. What are the lifecycle methods of a component?\par
\b0\f1 Lifecycle methods are a way to hook into the different stages of a component's life cycle, allowing you to execute specific code at specific times.\par
\par
Here is the list of the major lifecycle methods:\par
\b constructor\b0 : This is the first method called when a component is created. It is used for initializing state and binding event handlers. In functional components, you would use the useState hook for similar purposes.\par
\b render\b0 : This method is responsible for rendering JSX markup and returns the content to be displayed on the screen.\par
\b componentDidMoun\b0 t: This method is called immediately after the component is rendered in the DOM. It is commonly used for initialization tasks, such as API calls or setting up event listeners.\par
\b componentDidUpdate\b0 : This method is invoked when the component's props or state change. It allows you to perform side effects, update the component based on the changes, or trigger additional API calls.\par
\b componentWillUnmount\b0 : This method is called right before the component is removed from the DOM. It is used to clean up any resources that were set up in componentDidMount, such as removing event listeners or canceling timers.\par
\par
Some lifecycle methods, like componentWillMount, componentWillReceiveProps, and componentWillUpdate, have been deprecated or replaced with alternative methods or hooks.\par
\par
As for "this," it refers to the current instance of a class component. It allows you to access properties and methods within the component. In functional components, "this" is not used as functions are not bound to a specific instance.\par
\par
\b\f0 7. What are the peculiarities of using useState?\b0\f1\par
useState returns a state value and a function to update it.\par
const [value, setValue] = useState('Some state');\par
During the initial rendering, the returned state matches the value passed as the first argument. The setState function is used to update the state. It takes a new state value as a parameter and queues a re-render of the component. The setState function can also accept a callback function as a parameter, which takes the previous state value as a parameter.\par
Learn more\par
\par
\b\f0 8. What are the peculiarities of using useEffect?\b0\f1\par
The useEffect hook allows you to perform side effects in a functional component.\par
Mutations, subscriptions, timers, logging, and other side effects are not allowed inside the main body of a functional component known as the React rendering phase. This can lead to confusing errors and inconsistencies in the user interface.\par
Instead, it is recommended to use useEffect. The function passed to useEffect will be executed after the render is committed to the screen, or if you pass an array of dependencies as the second parameter, the function will be called every time one of the dependencies changes.\par
useEffect(() => \{\par
  console.log('Logging something');\par
\}, [])\par
Learn more\par
\par
\b\f0 9. How to track the unmounting of a functional component?\b0\f1\par
Often, useEffect create resources that need to be cleaned up or reset before the component leaves the screen, such as a subscription or a timer identifier.\par
In order to do this, the function passed to useEffect can return a cleanup function. The cleanup function is run before the component is removed from the user interface to prevent memory leaks. Additionally, if the component renders multiple times (as is usually the case), the previous effect is cleaned up before the next effect is executed.\par
useEffect(() => \{\par
  function handleChange(value) \{\par
    setValue(value);\par
  \}\par
  SomeAPI.doFunction(id, handleChange);\par
\par
  return function cleanup() \{\par
    SomeAPI.undoFunction(id, handleChange);\par
  \};\par
\})\par
\b\f0 10. What are props in React?\b0\f1\par
Props are data that is passed to the component from the parent. Props\par
are read-only and cannot be changed.\par
// Parent component\par
const Parent = () => \{\par
  const data = "Hello, World!";\par
\par
  return (\par
    <div>\par
      <Child data=\{data\} />\par
    </div>\par
  );\par
\};\par
\par
// Child component\par
const Child = (\{ data \}) => \{\par
  return <div>\{data\}</div>;\par
\};\par
Learn more\par
\par
\b\f0 11. What is a state manager and which ones have you worked with or know?\par
\b0\f1 State manager is a tool or library that helps manage the state of an application. It provides a centralized store or container for storing and managing data that can be accessed and updated by different components in the application.\par
A state manager solves several problems. Firstly, it is a good practice to separate data and the logic related to it from components. Secondly, when using local state and passing it between components, the code can become convoluted due to the potential for deep nesting of components. By having a global store, we can access and modify data from any component.\par
Alongside React Context, Redux or MobX are commonly used as state management libraries.\par
Learn more\par
Learn more\par
\par
\b\f0 12. In which cases can you use local state and when should you use global state?\par
\b0\f1 Local state is recommended to be used in cases where it is only used within one component and there are no plans to pass it to other components. Local state is also used in a component representing an individual item in a list. However, if component decomposition involves nested components with data being passed down the hierarchy, it is better to use global state.\par
\par
\b\f0 13. What is a reducer in Redux and what parameters does it take?\par
\b0\f1 A reducer is a pure function that takes the state and action as parameters. Inside the reducer, we track the type of the received action and, depending on it, we modify the state and return a new state object.\par
export default function appReducer(state = initialState, action) \{\par
  // The reducer normally looks at the action type field to decide what happens\par
  switch (action.type) \{\par
    // Do something here based on the different types of actions\par
    default:\par
      // If this reducer doesn't recognize the action type, or doesn't\par
      // care about this specific action, return the existing state unchanged\par
      return state\par
  \}\par
\}\par
Learn more\par
\par
\b\f0 14. What is an action and how can you change the state in Redux?\par
\b0\f1 Action is a simple JavaScript object that must have a field with\par
a type.\par
\{\par
  type: "SOME_TYPE"\par
\}\par
You can also optionally add some data as payload. In order to\par
change the state, it is necessary to call the dispatch function, to which we pass\par
action\par
\{\par
  type: "SOME_TYPE",\par
  payload: "Any payload",\par
\}\par
Learn more\par
\par
\b\f0 15. Which pattern does Redux implement?\par
\b0\f1 Redux implements the Flux pattern, which is a predictable state management pattern for applications. It helps in managing the state of an application by introducing a unidirectional data flow and a centralized store for the application's state.\par
Learn more\par
\par
\par
\par
\par
\b\f0 20. What is JSX?\par
\b0\f1 By default, the following syntax is used to create elements in react.\par
const someElement = React.createElement(\par
  'h3',\par
  \{className: 'title__value'\},\par
  'Some Title Value'\par
);\par
But we are used to seeing it like this\par
const someElement = (\par
  <h3 className='title__value'>Some Title Value</h3>\par
);\par
This is exactly what the markup is called jsx. This is a kind of language extension\par
that simplifies the perception of code and development\par
Learn more\par
\par
\b\f0 21. What is props drilling?\par
\b0\f1 Props drilling refers to the process of passing props through multiple levels of nested components, even if some intermediate components do not directly use those props. This can lead to a complex and cumbersome code structure.\par
// Parent component\par
const Parent = () => \{\par
  const data = "Hello, World!";\par
\par
  return (\par
    <div>\par
      <ChildA data=\{data\} />\par
    </div>\par
  );\par
\};\par
\par
// Intermediate ChildA component\par
const ChildA = (\{ data \}) => \{\par
  return (\par
    <div>\par
      <ChildB data=\{data\} />\par
    </div>\par
  );\par
\};\par
\par
// Leaf ChildB component\par
const ChildB = (\{ data \}) => \{\par
  return <div>\{data\}</div>;\par
\};\par
In this example, the data prop is passed from the Parent component to ChildA, and then from ChildA to ChildB even though ChildA doesn't directly use the prop. This can become problematic when there are many levels of nesting or when the data needs to be accessed by components further down the component tree. It can make the code harder to maintain and understand.\par
\par
Props drilling can be mitigated by using other patterns like context or state management libraries like Redux or MobX. These approaches allow data to be accessed by components without the need for passing props through every intermediate component.\par
\par
\b\f0 22. How to render an element conditionally?\par
\b0\f1 You can use any conditional operators, including ternary.\par
return (\par
  <div>\par
    \{isVisible && <span>I'm visible!</span>\}\par
  </div>\par
);\par
return (\par
  <div>\par
    \{isOnline ? <span>I'm online!</span> : <span>I'm offline</span>\}\par
  </div>\par
);\par
if (isOnline) \{\par
  element = <span>I'm online!</span>;\par
\} else \{\par
  element = <span>I'm offline</span>;\par
\}\par
\par
return (\par
  <div>\par
    \{element\}\par
  </div>\par
);\par
Learn more\par
\par
\b\f0 23. What is useMemo used for and how does it work?\par
\b0\f1 useMemo is used to memorised the value to improve the performance by caching the expansive  calculations.\par
Pass the creating function and an array of dependencies. useMemo will recalculate the memoized value only when the value of any of the dependencies has changed. This optimization helps to avoid costly calculations with each render.\par
With the first parameter, the function accepts a callback in which calculations are performed, and with the second an array of dependencies, the function will re-perform calculations only when at least one of the dependencies is changed.\par
const memoValue = useMemo(() => computeFunc(paramA, paramB), [paramA, paramB]);\par
Learn more\par
\par
\b\f0 24. What is useCallback used for and how does it work?\par
\b0\f1 The useCallback hook will return a memoized version of the callback, which changes only if the values of one of the dependencies change.\par
This is useful when passing callbacks to optimized child components that rely on link equality to prevent unnecessary renderings.\par
const callbackValue = useCallback(() => computeFunc(paramA, paramB), [paramA, paramB]);\par
Learn more\par
\par
\b\f0 25. What is the difference between useMemo and useCallback?\par
\b0\f1 useMemo is used to memoize the result of a computation, while useCallback is used to memoize a function itself.\par
useMemo caches the computed value and returns it on subsequent renders if the dependencies haven't changed.\par
useCallback caches the function itself and returns the same instance unless the dependencies have changed.\par
\b\f0 26. What is React Context?\par
\b0\f1 React Context is a feature that provides a way to pass data through the component tree without manually passing props at every level. It allows you to create a global state that can be accessed by any component within the tree, regardless of its position. Context is useful when you need to share data between multiple components that are not directly connected through props.\par
\par
The React Context API consists of three main parts:\par
\par
createContext: This function is used to create a new context object.\par
Context.Provider: This component is used to provide the value to the context. It wraps the components that need access to the value.\par
Context.Consumer or useContext hook: This component or hook is used to consume the value from the context. It can be used within any component within the context's provider.\par
By using React Context, you can avoid prop drilling (passing props through multiple levels of components) and easily manage state at a higher level, making your code more organized and efficient.\par
Learn more\par
\par
\b\f0 27. What is useContext used for and how does it work?\par
\b0\f1 In a typical React application, data is passed from top to bottom (from parent to child component) using props. However, such a method of use may be too cumbersome for some types of props\par
(for example, the selected language, UI theme), which must be passed to many components in the application. The context provides a way to share such data between components without having to explicitly pass the props through\par
each level of the tree.\par
The component calling useContext will always be re-rendered when\par
the context value changes. If re-rendering a component is costly, you can optimize it using memoization.\par
const App = () => \{\par
  const theme = useContext(ThemeContext);\par
\par
  return (\par
    <div style=\{\{ color: theme.palette.primary.main \}\}>\par
      Some div\par
    </div>\par
  );\par
\}\par
Learn more\par
\par
\b\f0 28. What is useRef used for and how does it work?\par
\b0\f1 useRef returns a modifiable ref object, a property. The current of which is initialized by the passed argument. The returned object will persist for the entire lifetime of the component and will not change from render to render.\par
The usual use case is to access the descendant in an imperative\par
style. I.e. using ref, we can explicitly refer to the DOM element.\par
const App = () => \{\par
  const inputRef = useRef(null);\par
\par
  const buttonClick = () => \{\par
    inputRef.current.focus();\par
  \}\par
\par
  return (\par
    <>\par
      <input ref=\{inputRef\} type="text" />\par
      <button onClick=\{buttonClick\}>Focus on input tag</button>\par
    </>\par
  )\par
\}\par
Learn more\par
\par
\b\f0 29. What is React.memo()?\par
\b0\f1 React.memo() is a higher\f2\emdash order component. If your component always renders the same thing with non-changing props, you can wrap it in a React.memo() call to improve performance in some cases, thereby memorizing the result. This means that React will use the result of the last render, avoiding re-rendering. React.memo() only affects changes to the props. If a functional component is wrapped in React.memo and uses useState, useReducer, or useContext, it will be re-rendered when the state or context changes.\par
import \{ memo \} from 'react';\par
\par
const MemoComponent = memo(MemoComponent = (props) => \{\par
  // ...\par
\});\par
Learn more\par
\par
\b\f0 30. What is React Fragment?\par
\b0\f2 Returning multiple elements from a component is a common practice in React. Fragments allow you to form a list of child elements without creating unnecessary nodes in the DOM.\par
<>\par
  <OneChild />\par
  <AnotherChild />\par
</>\par
// or\par
<React.Fragment>\par
  <OneChild />\par
  <AnotherChild />\par
</React.Fragment>\par
Learn more\par
\par
\b\f0 31. What is React Reconciliation?\par
\b0\f2 Reconciliation is a React algorithm used to distinguish one tree of elements from another to determine the parts that will need to be replaced.\par
Reconciliation is the algorithm behind what we used to call Virtual DOM. The definition sounds something like this: when you render a React application, the element tree that describes the application is generated in reserved memory. This tree is then included in the rendering environment - for example, a browser application, it is translated into a set of DOM operations. When the application state is updated, a new tree is generated. The new tree is compared with the previous one in order to calculate and enable exactly the operations that are needed to redraw the updated application.\par
Learn more\par
\par
\b\f0 32. Why do we need keys in lists when using map()?\par
\b0\f2 The keys help React determine which elements have been changed,\par
added, or removed. They must be specified so that React can match\par
array elements over time. The best way to choose a key is to use a string that will clearly distinguish the list item from its neighbors. Most often, you will use the IDs from your data as keys.\par
const languages = [\par
  \{\par
    id: 1,\par
    lang: "JavaScript",\par
  \},\par
  \{\par
    id: 2,\par
    lang: "TypeScript",\par
  \},\par
  \{\par
    id: 3,\par
    lang: "Python",\par
  \},\par
];\par
\par
const App = () => \{\par
  return (\par
    <div>\par
      <ul>\{languages.map((language) => (\par
        <li key=\{`$\{language.id\}_$\{language.lang\}`\}>\{language.lang\}</li>\par
      ))\}\par
      </ul>\par
    </div>\par
  );\par
\}\par
Learn more\par
\par
\b\f0 33. How to handle asynchronous actions in Redux Thunk?\par
\b0\f2 To use Redux Thunk, you need to import it as middleware. Action creators should return not just an object but a function that takes dispatch as a parameter.\par
export const addUser = (\{ firstName, lastName \}) => \{\par
  return dispatch => \{\par
    dispatch(addUserStart());\par
  \}\par
\par
  axios.post('{{\field{\*\fldinst{HYPERLINK https://jsonplaceholder.typicode.com/users }}{\fldrslt{https://jsonplaceholder.typicode.com/users\ul0\cf0}}}}\f2\fs22 ', \{\par
    firstName,\par
    lastName,\par
    completed: false\par
  \})\par
  .then(res => \{\par
    dispatch(addUserSuccess(res.data));\par
  \})\par
  .catch(error => \{\par
    dispatch(addUserError(error.message));\par
  \})\par
\}\par
Learn more\par
\par
\b\f0 34. How to track changes in a field of an object in a functional component?\par
\b0\f2 To do this, you need to use the useEffect hook and pass the field of the object as a dependency array.\par
useEffect(() => \{\par
  console.log('Changed!')\par
\}, [obj.someField])\par
35. How to access a DOM element?\par
Refs are created using React.createRef() or the useRef() hook and attached to React elements through the ref attribute. By accessing the created reference, we can gain access to the DOM element using ref.current.\par
const App = () => \{\par
  const myRef = useRef(null);\par
\par
  const handleClick = () => \{\par
    console.log(myRef.current); // Accessing the DOM element\par
  \};\par
\par
  return (\par
    <div>\par
      <input type="text" ref=\{myRef\} />\par
      <button onClick=\{handleClick\}>Click Me</button>\par
    </div>\par
  );\par
\}\par
\par
export default App;\par
\b\f0 36. What is a custom hook?\par
\b0\f2 Custom hook is a function that allows you to reuse logic between different components. It is a way to encapsulate reusable logic so that it can be easily shared and reused across multiple components. Custom hooks are functions that typically start with the word *use * and can call other hooks if needed.\par
Learn more\par
\par
\b\f0 37. What is Public API?\par
\b0\f2 In the context of index files, a Public API typically refers to the interface or functions that are exposed and accessible to external modules or components.\par
Here's a code example of an index file representing a Public API:\par
// index.js\par
\par
export function greet(name) \{\par
  return `Hello, $\{name\}!`;\par
\}\par
\par
export function calculateSum(a, b) \{\par
  return a + b;\par
\}\par
In this example, the index.js file acts as a Public API where the functions greet() and calculateSum() are exported and can be accessed from other modules by importing them. Other modules can import and use these functions as part of their implementation:\par
// main.js\par
\par
import \{ greet, calculateSum \} from './index.js';\par
\par
console.log(greet('John')); // Hello, John!\par
console.log(calculateSum(5, 3)); // 8\par
By exporting specific functions from the index file, we are defining the Public API of the module, allowing other modules to use those functions.\par
\par
\b\f0 38. What are the rules for creating a custom hook?\par
\b0\f2 Start the hook name with "use".\par
Use existing hooks if needed.\par
Don't call hooks conditionally.\par
Extract reusable logic into the custom hook.\par
Custom hooks must be pure functions.\par
Custom hooks can return values or other hooks.\par
Name the custom hook descriptively. Learn more\par
39. What is SSR (Server-Side Rendering)?\par
Server-Side Rendering (SSR) is a technique used to render pages on the server and send the fully rendered page to the client for display. It allows the server to generate the complete HTML markup of a web page, including its dynamic content, and send it to the client as a response to a request.\par
\par
In a traditional client-side rendering approach, the client receives a minimal HTML page and then makes additional requests to the server for data and resources, which are used to render the page on the client-side. This can lead to slower initial page loading times and negatively impact search engine optimization (SEO) since search engine crawlers have difficulty indexing JavaScript-driven content.\par
\par
With SSR, the server takes care of rendering the web page by executing the necessary JavaScript code to produce the final HTML. This means that the client receives the fully rendered page from the server, reducing the need for additional resource requests. SSR improves initial page load times and allows search engines to easily index the content, resulting in better SEO.\par
\par
SSR is commonly used in frameworks and libraries like Next.js for React and Nuxt.js for Vue.js to enable server-side rendering capabilities. These frameworks handle the server-side rendering logic for you, making it easier to implement SSR.\par
\par
\b\f0 40. What are the benefits of using SSR?\par
\b0\f2 Improved initial loading times: SSR allows the server to send a fully rendered HTML page to the client, reducing the amount of processing required on the client-side. This improves the initial loading times, as the user sees a complete page more quickly.\par
\par
\b SEO-friendly\b0 : Search engines can efficiently crawl and index the content of SSR pages because the fully rendered HTML is available in the initial response. This improves search engine visibility and helps with better search rankings.\par
\par
\b Accessibility\b0 : SSR ensures that the content is accessible to users who have JavaScript disabled or use assistive technologies. By generating HTML on the server, SSR provides a reliable and accessible user experience for all users.\par
\par
Performance in low-bandwidth environments: SSR reduces the amount of data needed to be downloaded by the client, making it beneficial for users in low-bandwidth or high-latency environments. This is particularly important for mobile users or users with slower internet connections.\par
\par
While SSR offers these benefits, it's important to note that it may introduce more server load and maintenance complexity compared to client-side rendering methods. Careful consideration should be given to factors such as caching, scalability, and server-side rendering performance optimizations.\par
\par
\par
\b\f0 43. What architectural solutions for React do you know?\par
\b0\f2 There are several architectural solutions and patterns for building React projects. Some popular ones include:\par
\par
MVC (Model-View-Controller): MVC is a traditional architectural pattern that separates an application into three main components - Model, View, and Controller. React can be used in the View layer to render the UI, while other libraries or frameworks can be used for the Model and Controller layers.\par
\par
\b Flux\b0 : Flux is an application architecture introduced by Facebook specifically for React applications. It follows a unidirectional data flow, where data flows in a single direction, making it easier to understand and debug the application's state changes.\par
\par
\b Atomic Design\b0 : Atomic Design is not specific to React but is a design methodology that divides the UI into smaller, reusable components. It encourages building components that are small, self-contained, and can be composed to create more complex UIs.\par
\par
\b Container and Component Pattern\b0 : This pattern separates the presentation (Component) from the logic and state management (Container). Components are responsible for rendering the UI, while Containers handle the business logic and state management.\par
\par
\b Feature-Sliced Design\b0 : It is a modern architectural approach used to organize and structure React applications. It aims to address the challenges of scalability, maintainability, and reusability by dividing the application codebase based on features or modules.\par
\f1\par
}
 